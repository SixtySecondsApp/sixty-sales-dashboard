import { describe, it, expect, beforeEach, vi } from 'vitest';
import { createMockJWT, mockSupabaseResponse, commonErrors } from '../setup';
import { 
  SecurityTestHelper, 
  APITestHelper, 
  ValidationTestHelper, 
  TestDataGenerator,
  RateLimitTestHelper
} from '../utils/testHelpers';

// Security-focused Edge Function simulation
class SecurityEdgeFunction {
  private supabaseClient: any;
  private rateLimitStore: Map<string, { count: number; resetTime: number }>;
  private failedAttempts: Map<string, { count: number; blockedUntil: number }>;

  constructor(supabaseClient: any) {
    this.supabaseClient = supabaseClient;
    this.rateLimitStore = new Map();
    this.failedAttempts = new Map();
  }

  async handleRequest(request: Request): Promise<Response> {
    try {
      // Security headers
      const securityHeaders = {
        'Content-Type': 'application/json',
        'X-Content-Type-Options': 'nosniff',
        'X-Frame-Options': 'DENY',
        'X-XSS-Protection': '1; mode=block',
        'Referrer-Policy': 'no-referrer',
        'Content-Security-Policy': "default-src 'none'",
        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains'
      };

      // Rate limiting with progressive penalties
      const clientId = this.getClientId(request);
      const rateLimitResult = this.checkAdvancedRateLimit(clientId);
      if (!rateLimitResult.allowed) {
        return this.createSecureErrorResponse(
          'Rate limit exceeded',
          429,
          rateLimitResult.retryAfter ? `Retry after ${rateLimitResult.retryAfter} seconds` : undefined,
          securityHeaders
        );
      }

      // Method validation
      if (request.method !== 'POST') {
        return this.createSecureErrorResponse(
          'Method not allowed',
          405,
          undefined,
          securityHeaders
        );
      }

      // Content-Type validation
      if (!request.headers.get('content-type')?.includes('application/json')) {
        return this.createSecureErrorResponse(
          'Invalid content type',
          415,
          'Content-Type must be application/json',
          securityHeaders
        );
      }

      // Authentication with security checks
      const authResult = await this.validateAuthWithSecurity(request, clientId);
      if (!authResult.success) {
        this.recordFailedAttempt(clientId);
        return this.createSecureErrorResponse(
          'Authentication failed',
          401,
          authResult.error,
          securityHeaders
        );
      }

      // Parse body with security validation
      const bodyResult = await this.parseSecureBody(request);
      if (!bodyResult.success) {
        return this.createSecureErrorResponse(
          'Invalid request body',
          400,
          bodyResult.error,
          securityHeaders
        );
      }

      // Input validation and sanitization with security focus
      const validationResult = this.validateInputSecurity(bodyResult.data);
      if (!validationResult.isValid) {
        return this.createSecureErrorResponse(
          'Input validation failed',
          400,
          validationResult.errors.join(', '),
          securityHeaders
        );
      }

      // Success response with security headers
      return new Response(JSON.stringify({
        message: 'Request processed successfully',
        sanitized_data: validationResult.sanitized
      }), {
        status: 200,
        headers: securityHeaders
      });

    } catch (error: any) {
      // Never expose internal errors to clients
      return this.createSecureErrorResponse(
        'Internal server error',
        500,
        undefined,
        { 'Content-Type': 'application/json' }
      );
    }
  }

  private createSecureErrorResponse(
    error: string,
    status: number,
    details?: string,
    headers: Record<string, string> = {}
  ): Response {
    // Sanitize error messages to prevent information disclosure
    const sanitizedError = this.sanitizeErrorMessage(error, status);
    const sanitizedDetails = details ? this.sanitizeErrorMessage(details, status) : undefined;

    return new Response(JSON.stringify({
      error: sanitizedError,
      details: sanitizedDetails,
      timestamp: new Date().toISOString()
    }), {
      status,
      headers: {
        'Content-Type': 'application/json',
        ...headers
      }
    });
  }

  private sanitizeErrorMessage(message: string, status: number): string {
    // For client errors, provide specific messages
    if (status >= 400 && status < 500) {
      return message.replace(/[<>\"'&]/g, ''); // Remove XSS characters
    }
    // For server errors, provide generic messages
    return 'Internal server error';
  }

  private getClientId(request: Request): string {
    const forwarded = request.headers.get('x-forwarded-for');
    const realIp = request.headers.get('x-real-ip');
    const ipAddress = forwarded?.split(',')[0] || realIp || 'unknown';
    const userAgent = request.headers.get('user-agent') || 'unknown';
    
    // Sanitize to prevent injection
    const sanitizedIp = ipAddress.replace(/[^0-9a-fA-F:.]/g, '').slice(0, 50);
    const sanitizedUA = userAgent.replace(/[<>\"'&]/g, '').slice(0, 100);
    
    return `${sanitizedIp}-${sanitizedUA}`;
  }

  private checkAdvancedRateLimit(clientId: string): { allowed: boolean; retryAfter?: number } {
    const now = Date.now();
    
    // Check if client is temporarily blocked due to failed attempts
    const failedAttempt = this.failedAttempts.get(clientId);
    if (failedAttempt && now < failedAttempt.blockedUntil) {
      const retryAfter = Math.ceil((failedAttempt.blockedUntil - now) / 1000);
      return { allowed: false, retryAfter };
    }

    // Standard rate limiting
    const limit = 5;
    const windowMs = 60000;
    const clientData = this.rateLimitStore.get(clientId);
    
    if (!clientData || now > clientData.resetTime) {
      this.rateLimitStore.set(clientId, { count: 1, resetTime: now + windowMs });
      return { allowed: true };
    }
    
    if (clientData.count >= limit) {
      return { allowed: false };
    }
    
    clientData.count++;
    return { allowed: true };
  }

  private recordFailedAttempt(clientId: string): void {
    const now = Date.now();
    const existing = this.failedAttempts.get(clientId);
    
    if (!existing) {
      this.failedAttempts.set(clientId, { count: 1, blockedUntil: 0 });
    } else {
      existing.count++;
      // Progressive blocking: 1min, 5min, 15min, 1hour
      const blockDurations = [60000, 300000, 900000, 3600000];
      const blockIndex = Math.min(existing.count - 3, blockDurations.length - 1);
      
      if (existing.count >= 3) {
        existing.blockedUntil = now + blockDurations[blockIndex];
      }
    }
  }

  private async validateAuthWithSecurity(request: Request, clientId: string): Promise<{ success: boolean; error?: string }> {
    const authHeader = request.headers.get('authorization');
    
    if (!authHeader) {
      return { success: false, error: 'Authorization header missing' };
    }

    if (!authHeader.startsWith('Bearer ')) {
      return { success: false, error: 'Invalid authorization format' };
    }

    const token = authHeader.replace('Bearer ', '');
    
    // Validate token format before processing
    if (token.length > 2048) { // JWT tokens shouldn't be extremely long
      return { success: false, error: 'Token too long' };
    }

    if (!/^[A-Za-z0-9._-]+$/.test(token.replace(/\./g, ''))) {
      return { success: false, error: 'Invalid token format' };
    }

    try {
      const { data: { user }, error } = await this.supabaseClient.auth.getUser(token);
      
      if (error || !user) {
        return { success: false, error: 'Invalid or expired token' };
      }

      // Additional security: validate user ID format
      if (!ValidationTestHelper.validateUUIDFormat(user.id)) {
        return { success: false, error: 'Invalid user identifier' };
      }

      return { success: true };
    } catch (error) {
      return { success: false, error: 'Token verification failed' };
    }
  }

  private async parseSecureBody(request: Request): Promise<{ success: boolean; data?: any; error?: string }> {
    try {
      const text = await request.text();
      
      // Validate JSON size
      if (text.length > 10240) { // 10KB limit
        return { success: false, error: 'Request body too large' };
      }

      // Check for potentially malicious patterns
      if (this.containsSuspiciousPatterns(text)) {
        return { success: false, error: 'Suspicious content detected' };
      }

      const data = JSON.parse(text);
      
      // Validate object structure
      if (typeof data !== 'object' || data === null || Array.isArray(data)) {
        return { success: false, error: 'Request body must be an object' };
      }

      return { success: true, data };
    } catch (error) {
      return { success: false, error: 'Invalid JSON format' };
    }
  }

  private containsSuspiciousPatterns(text: string): boolean {
    const suspiciousPatterns = [
      // SQL injection patterns
      /(\b(union|select|insert|update|delete|drop|alter|create)\s)/i,
      /(\b(or|and)\s+\d+\s*=\s*\d+)/i,
      
      // Script injection patterns
      /<script\b/i,
      /javascript:/i,
      /on\w+\s*=/i,
      
      // Command injection patterns
      /[;&|`$()]/,
      
      // Path traversal patterns
      /\.\.[\/\\]/,
      
      // Null bytes
      /\x00/,
    ];

    return suspiciousPatterns.some(pattern => pattern.test(text));
  }

  private validateInputSecurity(data: any): { isValid: boolean; errors: string[]; sanitized?: any } {
    const errors: string[] = [];
    const sanitized: any = {};

    // Validate name with security focus
    if (data.name !== undefined) {
      if (typeof data.name !== 'string') {
        errors.push('name must be a string');
      } else {
        const name = data.name.trim();
        
        // Length validation
        if (name.length < 3 || name.length > 100) {
          errors.push('name must be between 3 and 100 characters');
        }
        
        // Security: check for malicious patterns
        if (this.containsXSSPatterns(name)) {
          errors.push('name contains prohibited characters');
        } else {
          sanitized.name = this.sanitizeString(name);
        }
      }
    } else {
      errors.push('name is required');
    }

    // Validate permissions with strict security
    if (data.permissions !== undefined) {
      if (!Array.isArray(data.permissions)) {
        errors.push('permissions must be an array');
      } else {
        const validPermissions = ['deals:read', 'deals:write', 'contacts:read', 'contacts:write', 'activities:read'];
        const sanitizedPermissions: string[] = [];
        
        for (const permission of data.permissions) {
          if (typeof permission !== 'string') {
            errors.push('all permissions must be strings');
            break;
          }
          
          const cleanPermission = permission.trim().toLowerCase();
          
          // Strict validation - only allow exact matches
          if (!validPermissions.includes(cleanPermission)) {
            errors.push(`invalid permission: ${permission}`);
            break;
          }
          
          if (!sanitizedPermissions.includes(cleanPermission)) {
            sanitizedPermissions.push(cleanPermission);
          }
        }
        
        if (sanitizedPermissions.length > 0 && errors.length === 0) {
          sanitized.permissions = sanitizedPermissions;
        }
      }
    } else {
      errors.push('permissions are required');
    }

    // Validate rate_limit with security bounds
    if (data.rate_limit !== undefined) {
      if (typeof data.rate_limit !== 'number' || !Number.isInteger(data.rate_limit)) {
        errors.push('rate_limit must be an integer');
      } else if (data.rate_limit < 1 || data.rate_limit > 10000) {
        errors.push('rate_limit must be between 1 and 10000');
      } else {
        sanitized.rate_limit = data.rate_limit;
      }
    } else {
      sanitized.rate_limit = 500; // Safe default
    }

    return {
      isValid: errors.length === 0,
      errors,
      sanitized: errors.length === 0 ? sanitized : undefined
    };
  }

  private containsXSSPatterns(text: string): boolean {
    const xssPatterns = [
      /<[^>]*script/i,
      /<[^>]*on\w+/i,
      /javascript:/i,
      /<[^>]*iframe/i,
      /<[^>]*object/i,
      /<[^>]*embed/i,
      /<[^>]*link/i,
      /<[^>]*style/i,
    ];

    return xssPatterns.some(pattern => pattern.test(text));
  }

  private sanitizeString(input: string): string {
    return input
      .replace(/[<>\"'&]/g, '') // Remove dangerous characters
      .replace(/\s+/g, ' ') // Normalize whitespace
      .trim()
      .slice(0, 100); // Enforce length limit
  }
}

describe('Security Vulnerability Prevention Tests', () => {
  let securityFunction: SecurityEdgeFunction;
  let mockSupabase: any;

  beforeEach(() => {
    mockSupabase = {
      auth: {
        getUser: vi.fn()
      }
    };
    securityFunction = new SecurityEdgeFunction(mockSupabase);
  });

  describe('XSS Prevention', () => {
    it('should prevent XSS in name field', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      const xssPayloads = SecurityTestHelper.generateXSSPayloads();

      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Act & Assert
      for (const xssPayload of xssPayloads) {
        const request = APITestHelper.createMockRequest('POST', {
          name: xssPayload,
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json'
        });

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(400);
        expect(result.error).toBe('Input validation failed');
        expect(result.details).toContain('prohibited characters');
      }
    });

    it('should sanitize XSS attempts in successful requests', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      const request = APITestHelper.createMockRequest('POST', {
        name: 'Normal name with <script>alert("xss")</script> embedded',
        permissions: ['deals:read']
      }, {
        'Authorization': `Bearer ${validToken}`,
        'Content-Type': 'application/json'
      });

      // Act
      const response = await securityFunction.handleRequest(request);
      const result = await APITestHelper.parseResponse(response);

      // Assert
      expect(response.status).toBe(400); // Should be rejected due to XSS patterns
      expect(result.details).toContain('prohibited characters');
    });

    it('should set proper XSS protection headers', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      const request = APITestHelper.createMockRequest('POST', {
        name: 'Safe Name',
        permissions: ['deals:read']
      }, {
        'Authorization': `Bearer ${validToken}`,
        'Content-Type': 'application/json'
      });

      // Act
      const response = await securityFunction.handleRequest(request);

      // Assert
      expect(response.headers.get('X-XSS-Protection')).toBe('1; mode=block');
      expect(response.headers.get('X-Content-Type-Options')).toBe('nosniff');
      expect(response.headers.get('X-Frame-Options')).toBe('DENY');
      expect(response.headers.get('Content-Security-Policy')).toBe("default-src 'none'");
    });

    it('should prevent XSS in error messages', async () => {
      // Arrange
      const xssToken = '<script>alert("xss")</script>';
      const request = APITestHelper.createMockRequest('POST', {
        name: 'Test',
        permissions: ['deals:read']
      }, {
        'Authorization': `Bearer ${xssToken}`,
        'Content-Type': 'application/json'
      });

      // Act
      const response = await securityFunction.handleRequest(request);
      const result = await APITestHelper.parseResponse(response);

      // Assert
      expect(response.status).toBe(401);
      expect(result.error).not.toContain('<script>');
      expect(result.error).not.toContain('alert');
      expect(result.details).not.toContain('<script>');
    });
  });

  describe('SQL Injection Prevention', () => {
    it('should prevent SQL injection in request body', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      const sqlInjectionPayloads = SecurityTestHelper.generateSQLInjectionPayloads();

      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Act & Assert
      for (const sqlPayload of sqlInjectionPayloads) {
        const request = APITestHelper.createMockRequest('POST', {
          name: sqlPayload,
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json'
        });

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(400);
        expect(result.error).toBe('Suspicious content detected');
      }
    });

    it('should detect SQL injection in JSON strings', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      const maliciousJson = JSON.stringify({
        name: "'; DROP TABLE api_keys; --",
        permissions: ['deals:read']
      });

      const request = new Request('https://test.example.com', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json'
        },
        body: maliciousJson
      });

      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Act
      const response = await securityFunction.handleRequest(request);
      const result = await APITestHelper.parseResponse(response);

      // Assert
      expect(response.status).toBe(400);
      expect(result.error).toBe('Suspicious content detected');
    });

    it('should handle union-based SQL injection attempts', async () => {
      // Arrange
      const maliciousPayloads = [
        "1' UNION SELECT * FROM users--",
        "admin' OR '1'='1",
        "'; INSERT INTO api_keys VALUES ('evil'); --"
      ];

      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Act & Assert
      for (const payload of maliciousPayloads) {
        const request = APITestHelper.createMockRequest('POST', {
          name: payload,
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json'
        });

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(400);
        expect(result.error).toBe('Suspicious content detected');
      }
    });
  });

  describe('JWT Security', () => {
    it('should reject malformed JWT tokens', async () => {
      // Arrange
      const malformedTokens = SecurityTestHelper.generateInvalidJWT();

      // Act & Assert
      for (const token of malformedTokens) {
        const request = APITestHelper.createMockRequest('POST', {
          name: 'Test',
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        });

        mockSupabase.auth.getUser.mockResolvedValue(
          mockSupabaseResponse(null, commonErrors.INVALID_TOKEN)
        );

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(401);
        expect(result.error).toBe('Authentication failed');
      }
    });

    it('should reject extremely long JWT tokens', async () => {
      // Arrange
      const longToken = 'a'.repeat(3000); // Extremely long token
      const request = APITestHelper.createMockRequest('POST', {
        name: 'Test',
        permissions: ['deals:read']
      }, {
        'Authorization': `Bearer ${longToken}`,
        'Content-Type': 'application/json'
      });

      // Act
      const response = await securityFunction.handleRequest(request);
      const result = await APITestHelper.parseResponse(response);

      // Assert
      expect(response.status).toBe(401);
      expect(result.error).toBe('Authentication failed');
      expect(result.details).toBe('Token too long');
    });

    it('should reject tokens with invalid characters', async () => {
      // Arrange
      const invalidTokens = [
        'header.payload.signature<script>',
        'header.payload.signature"OR"1"="1',
        'header.payload.signature\x00',
        'header.payload.signature\n\r',
      ];

      // Act & Assert
      for (const token of invalidTokens) {
        const request = APITestHelper.createMockRequest('POST', {
          name: 'Test',
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        });

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(401);
        expect(result.error).toBe('Authentication failed');
        expect(result.details).toBe('Invalid token format');
      }
    });

    it('should validate user ID format strictly', async () => {
      // Arrange
      const invalidUserIds = [
        'not-a-uuid',
        '12345',
        'admin', 
        '../../../etc/passwd',
        '<script>alert("xss")</script>',
      ];

      const validToken = createMockJWT();

      // Act & Assert
      for (const userId of invalidUserIds) {
        mockSupabase.auth.getUser.mockResolvedValue(
          mockSupabaseResponse({ user: { id: userId } })
        );

        const request = APITestHelper.createMockRequest('POST', {
          name: 'Test',
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json'
        });

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(401);
        expect(result.error).toBe('Authentication failed');
        expect(result.details).toBe('Invalid user identifier');
      }
    });
  });

  describe('Rate Limiting Security', () => {
    it('should implement progressive rate limiting for failed attempts', async () => {
      // Arrange
      const clientHeaders = {
        'X-Forwarded-For': '192.168.1.100',
        'User-Agent': 'attack-bot/1.0',
        'Content-Type': 'application/json'
      };

      // Act - Make failed authentication attempts
      const responses: Response[] = [];
      for (let i = 0; i < 6; i++) {
        const request = APITestHelper.createMockRequest('POST', {
          name: 'Test',
          permissions: ['deals:read']
        }, {
          'Authorization': 'Bearer invalid_token',
          ...clientHeaders
        });

        mockSupabase.auth.getUser.mockResolvedValue(
          mockSupabaseResponse(null, commonErrors.INVALID_TOKEN)
        );

        responses.push(await securityFunction.handleRequest(request));
      }

      // Assert - First few should be 401, later ones might be blocked
      const authFailures = responses.filter(r => r.status === 401).length;
      const rateLimited = responses.filter(r => r.status === 429).length;

      expect(authFailures).toBeGreaterThan(0);
      expect(rateLimited).toBeGreaterThan(0); // Should eventually rate limit
    });

    it('should handle rate limit bypass attempts', async () => {
      // Arrange - Try to bypass rate limiting with different headers
      const bypassAttempts = [
        { 'X-Forwarded-For': '192.168.1.1', 'User-Agent': 'bot1' },
        { 'X-Forwarded-For': '192.168.1.1,10.0.0.1', 'User-Agent': 'bot1' }, // Proxy chain
        { 'X-Real-IP': '10.0.0.1', 'User-Agent': 'bot1' }, // Different IP header
        { 'X-Forwarded-For': '192.168.1.1', 'User-Agent': 'bot2' }, // Different UA
      ];

      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Exhaust rate limit for first client
      for (let i = 0; i < 5; i++) {
        const request = APITestHelper.createMockRequest('POST', {
          name: 'Test',
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json',
          ...bypassAttempts[0]
        });

        await securityFunction.handleRequest(request);
      }

      // Act - Try bypass attempts
      const bypassResponses: Response[] = [];
      for (const headers of bypassAttempts) {
        const request = APITestHelper.createMockRequest('POST', {
          name: 'Bypass Test',
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json',
          ...headers
        });

        bypassResponses.push(await securityFunction.handleRequest(request));
      }

      // Assert - Different client IDs should be treated separately
      const results = await Promise.all(bypassResponses.map(r => APITestHelper.parseResponse(r)));
      
      // Original client should still be rate limited
      expect(bypassResponses[0].status).toBe(429);
      
      // Different clients should be allowed (up to their limits)
      expect(bypassResponses[2].status).toBe(200); // Different IP header
      expect(bypassResponses[3].status).toBe(200); // Different user agent
    });

    it('should sanitize client identification to prevent injection', async () => {
      // Arrange
      const maliciousHeaders = [
        { 'X-Forwarded-For': '192.168.1.1<script>alert("xss")</script>' },
        { 'User-Agent': 'Mozilla/5.0 ("; DROP TABLE clients; --")' },
        { 'X-Real-IP': '10.0.0.1\x00\x01\x02' }, // Null bytes
        { 'X-Forwarded-For': '192.168.1.1\r\n\r\nHost: evil.com' }, // HTTP header injection
      ];

      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Act & Assert
      for (const headers of maliciousHeaders) {
        const request = APITestHelper.createMockRequest('POST', {
          name: 'Test',
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json',
          ...headers
        });

        // Should not throw errors due to malicious headers
        const response = await securityFunction.handleRequest(request);
        expect([200, 429]).toContain(response.status); // Should work or be rate limited
      }
    });
  });

  describe('Input Validation Security', () => {
    it('should reject oversized payloads', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      const largePayload = {
        name: 'a'.repeat(5000), // Very long name
        permissions: ['deals:read']
      };

      const request = APITestHelper.createMockRequest('POST', largePayload, {
        'Authorization': `Bearer ${validToken}`,
        'Content-Type': 'application/json'
      });

      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Act
      const response = await securityFunction.handleRequest(request);
      const result = await APITestHelper.parseResponse(response);

      // Assert
      expect(response.status).toBe(400);
      expect(result.error).toBe('Invalid request body');
      expect(result.details).toBe('Request body too large');
    });

    it('should validate permissions strictly', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      const invalidPermissions = [
        ['admin:all'], // Non-existent permission
        ['deals:execute'], // Invalid operation
        ['../../../etc/passwd:read'], // Path traversal attempt
        ['system:shutdown'], // System-level permission
        ['<script>:alert'], // XSS attempt
      ];

      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Act & Assert
      for (const permissions of invalidPermissions) {
        const request = APITestHelper.createMockRequest('POST', {
          name: 'Test',
          permissions
        }, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json'
        });

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(400);
        expect(result.error).toBe('Input validation failed');
        expect(result.details).toContain('invalid permission');
      }
    });

    it('should enforce strict data types', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      const invalidTypePayloads = [
        { name: 123, permissions: ['deals:read'] }, // Number instead of string
        { name: 'Test', permissions: 'deals:read' }, // String instead of array
        { name: 'Test', permissions: [123] }, // Number in array
        { name: 'Test', permissions: ['deals:read'], rate_limit: '500' }, // String instead of number
        { name: null, permissions: ['deals:read'] }, // Null value
      ];

      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Act & Assert
      for (const payload of invalidTypePayloads) {
        const request = APITestHelper.createMockRequest('POST', payload, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': 'application/json'
        });

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(400);
        expect(result.error).toBe('Input validation failed');
      }
    });

    it('should handle malicious JSON structures', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      const maliciousStructures = [
        [], // Array instead of object
        null, // Null
        'string', // String
        123, // Number
      ];

      mockSupabase.auth.getUser.mockResolvedValue(
        mockSupabaseResponse({ user: { id: userId } })
      );

      // Act & Assert
      for (const structure of maliciousStructures) {
        const request = new Request('https://test.example.com', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${validToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(structure)
        });

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(400);
        expect(result.error).toBe('Invalid request body');
        expect(result.details).toBe('Request body must be an object');
      }
    });
  });

  describe('Content-Type Security', () => {
    it('should reject non-JSON content types', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      const invalidContentTypes = [
        'text/plain',
        'text/html',
        'application/xml',
        'multipart/form-data',
        'application/x-www-form-urlencoded',
      ];

      // Act & Assert
      for (const contentType of invalidContentTypes) {
        const request = APITestHelper.createMockRequest('POST', {
          name: 'Test',
          permissions: ['deals:read']
        }, {
          'Authorization': `Bearer ${validToken}`,
          'Content-Type': contentType
        });

        const response = await securityFunction.handleRequest(request);
        const result = await APITestHelper.parseResponse(response);

        expect(response.status).toBe(415);
        expect(result.error).toBe('Invalid content type');
      }
    });

    it('should handle missing content type', async () => {
      // Arrange
      const userId = TestDataGenerator.randomUUID();
      const validToken = createMockJWT({ sub: userId });
      
      const request = new Request('https://test.example.com', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${validToken}`
          // No Content-Type header
        },
        body: JSON.stringify({
          name: 'Test',
          permissions: ['deals:read']
        })
      });

      // Act
      const response = await securityFunction.handleRequest(request);
      const result = await APITestHelper.parseResponse(response);

      // Assert
      expect(response.status).toBe(415);
      expect(result.error).toBe('Invalid content type');
    });
  });

  describe('Security Headers', () => {
    it('should set comprehensive security headers', async () => {
      // Arrange
      const request = APITestHelper.createMockRequest('POST', {}, {
        'Content-Type': 'application/json'
      });

      // Act
      const response = await securityFunction.handleRequest(request);

      // Assert
      expect(response.headers.get('X-Content-Type-Options')).toBe('nosniff');
      expect(response.headers.get('X-Frame-Options')).toBe('DENY');
      expect(response.headers.get('X-XSS-Protection')).toBe('1; mode=block');
      expect(response.headers.get('Referrer-Policy')).toBe('no-referrer');
      expect(response.headers.get('Content-Security-Policy')).toBe("default-src 'none'");
      expect(response.headers.get('Strict-Transport-Security')).toBe('max-age=31536000; includeSubDomains');
    });

    it('should maintain security headers even in error responses', async () => {
      // Arrange
      const request = APITestHelper.createMockRequest('GET', {}); // Wrong method

      // Act
      const response = await securityFunction.handleRequest(request);

      // Assert
      expect(response.status).toBe(405);
      expect(response.headers.get('X-Content-Type-Options')).toBe('nosniff');
      expect(response.headers.get('X-Frame-Options')).toBe('DENY');
      expect(response.headers.get('X-XSS-Protection')).toBe('1; mode=block');
    });
  });
});