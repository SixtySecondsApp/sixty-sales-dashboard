name: Sync Production Data to Development

on:
  schedule:
    # Run weekly on Sunday at 2 AM UTC (configurable)
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      force_refresh:
        description: 'Force refresh even if no recent changes'
        required: false
        default: 'false'
        type: boolean

env:
  SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID }}
  SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

jobs:
  sync-production-to-development:
    name: Sync Production â†’ Development Branch
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Authenticate with Supabase
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          # Authenticate using the access token
          supabase login --token $SUPABASE_ACCESS_TOKEN

      - name: Get Development Branch ID
        id: get-dev-branch
        run: |
          echo "ðŸ” Finding development branch..."
          
          # List all branches and find the development branch
          BRANCHES=$(supabase branches list --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json || echo "[]")
          
          DEV_BRANCH=$(echo "$BRANCHES" | jq -r '.[] | select(.name == "development") | .id' || echo "")
          
          if [ -z "$DEV_BRANCH" ]; then
            echo "âŒ Development branch not found. Creating it..."
            
            # Create development branch if it doesn't exist
            DEV_BRANCH=$(supabase branches create development --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json | jq -r '.id' || echo "")
            
            if [ -z "$DEV_BRANCH" ]; then
              echo "âŒ Failed to create development branch"
              exit 1
            fi
            
            echo "âœ… Created development branch: $DEV_BRANCH"
          else
            echo "âœ… Found development branch: $DEV_BRANCH"
          fi
          
          echo "branch_id=$DEV_BRANCH" >> $GITHUB_OUTPUT

      - name: Get Development Branch Connection String
        id: get-dev-connection
        run: |
          echo "ðŸ” Getting development branch connection details..."

          BRANCH_INFO=$(supabase branches get ${{ steps.get-dev-branch.outputs.branch_id }} --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json || echo "{}")

          # Debug: Show the branch info
          echo "ðŸ“‹ Branch info response:"
          echo "$BRANCH_INFO" | jq '.' || echo "Failed to parse JSON"

          # Extract the non-pooling connection URL and convert to pooled URL
          # The CLI returns POSTGRES_URL_NON_POOLING which we need to convert to pooled
          NON_POOLING_URL=$(echo "$BRANCH_INFO" | jq -r '.POSTGRES_URL_NON_POOLING // empty' || echo "")

          if [ -z "$NON_POOLING_URL" ]; then
            echo "âŒ Could not extract POSTGRES_URL_NON_POOLING from branch info"
            echo "Available fields in response:"
            echo "$BRANCH_INFO" | jq 'keys' || echo "No keys available"
            exit 1
          fi

          echo "ðŸ“‹ Non-pooling URL found"

          # Extract database host and database name from the URL
          # Format: postgresql://postgres:[PASSWORD]@[HOST]:[PORT]/[DATABASE]?[PARAMS]
          # We need to extract the database name and use Supavisor pooler

          # Extract just the database name from the URL (after the last /)
          DB_NAME=$(echo "$NON_POOLING_URL" | sed -n 's/.*\/\([^?]*\).*/\1/p')

          if [ -z "$DB_NAME" ]; then
            echo "âŒ Could not extract database name from connection URL"
            exit 1
          fi

          echo "ðŸ“‹ Database name: $DB_NAME"

          # Use Supavisor pooler with Session Mode (port 5432) for IPv4 compatibility
          # This matches the production connection format
          DB_URL="postgres://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@aws-0-us-west-1.pooler.supabase.com:5432/$DB_NAME"

          echo "db_url=$DB_URL" >> $GITHUB_OUTPUT
          echo "âœ… Development branch connection configured"

      - name: Export Production Data
        run: |
          echo "ðŸ“¦ Exporting production data via Supavisor Session Mode (IPv4)..."

          # Use pg_dump with Supavisor Session Mode (port 5432) for IPv4 compatibility
          # This is required because GitHub Actions runners don't support IPv6
          pg_dump "$PRODUCTION_DB_URL" \
            --no-owner \
            --no-privileges \
            --schema=public \
            -Fc \
            -f production_dump.sql

          echo "âœ… Production data exported"

          # Get dump size
          DUMP_SIZE=$(du -h production_dump.sql | cut -f1)
          echo "âœ… Production data size: $DUMP_SIZE"
          echo "dump_size=$DUMP_SIZE" >> $GITHUB_OUTPUT
        env:
          # Supavisor Session Mode (port 5432) provides IPv4 compatibility
          # Format: postgres://postgres.PROJECT_REF:PASSWORD@aws-0-REGION.pooler.supabase.com:5432/postgres
          PRODUCTION_DB_URL: "postgres://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@aws-0-us-west-1.pooler.supabase.com:5432/postgres"

      - name: Restore Data to Development Branch
        run: |
          echo "ðŸ”„ Restoring data to development branch via Supavisor..."

          # Use the connection URL provided by Supabase CLI (already includes Supavisor pooler for IPv4)
          DEV_DB_URL="${{ steps.get-dev-connection.outputs.db_url }}"

          # Show connection info (without password)
          DEV_BRANCH_HOST=$(echo "$DEV_DB_URL" | sed -n 's/.*@\([^:]*\):.*/\1/p')
          echo "ðŸ“¡ Connecting to development branch at: $DEV_BRANCH_HOST"

          # First, drop foreign key constraints that might cause issues
          echo "ðŸ”§ Temporarily dropping foreign key constraints..."
          psql --dbname="$DEV_DB_URL" <<'EOF' || true
          -- Drop FK constraints that reference tasks table
          ALTER TABLE IF EXISTS meeting_action_items DROP CONSTRAINT IF EXISTS meeting_action_items_task_id_fkey CASCADE;
          ALTER TABLE IF EXISTS next_action_suggestions DROP CONSTRAINT IF EXISTS next_action_suggestions_created_task_id_fkey CASCADE;
          EOF

          # Use pg_restore with the CLI-provided connection string
          # Remove --clean flag to avoid dropping functions with triggers on auth.users
          # Use --data-only to avoid schema conflicts, since the branch already has the schema
          echo "ðŸ“¦ Restoring data..."
          pg_restore \
            --dbname="$DEV_DB_URL" \
            --no-owner \
            --no-privileges \
            --data-only \
            --disable-triggers \
            production_dump.sql || {
              echo "âš ï¸  pg_restore completed with warnings (this is expected for branch databases)"
              echo "Continuing with verification..."
            }

          # Restore foreign key constraints
          echo "ðŸ”§ Restoring foreign key constraints..."
          psql --dbname="$DEV_DB_URL" <<'EOF' || true
          -- Restore FK constraints
          ALTER TABLE meeting_action_items
            ADD CONSTRAINT meeting_action_items_task_id_fkey
            FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE SET NULL;

          ALTER TABLE next_action_suggestions
            ADD CONSTRAINT next_action_suggestions_created_task_id_fkey
            FOREIGN KEY (created_task_id) REFERENCES tasks(id) ON DELETE SET NULL;
          EOF

          echo "âœ… Data restored to development branch"

      - name: Verify Data Sync
        run: |
          echo "ðŸ” Verifying data sync..."

          # Check table counts using development branch connection
          psql --dbname="${{ steps.get-dev-connection.outputs.db_url }}" <<EOF
          SELECT 
            schemaname,
            tablename,
            pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
          FROM pg_tables 
          WHERE schemaname = 'public'
          ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
          LIMIT 10;
          EOF
          
          echo "âœ… Data sync verification complete"

      - name: Sync Summary
        if: always()
        run: |
          echo "## ðŸ”„ Production â†’ Development Data Sync" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Source**: Production Database" >> $GITHUB_STEP_SUMMARY
          echo "- **Target**: Development Branch (\`${{ steps.get-dev-branch.outputs.branch_id }}\`)" >> $GITHUB_STEP_SUMMARY
          echo "- **Dump Size**: ${{ steps.get-dev-connection.outputs.dump_size || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status == 'success' && 'âœ… Completed' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Sync Time**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          rm -f production_dump.dump
          echo "ðŸ§¹ Cleanup complete"

