name: Production Deploy with Performance Testing\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n  workflow_dispatch:\n    inputs:\n      deploy_environment:\n        description: 'Deployment environment'\n        required: true\n        default: 'staging'\n        type: choice\n        options:\n        - staging\n        - production\n\nenv:\n  NODE_VERSION: '20'\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n  PERFORMANCE_THRESHOLD_LCP: 2500  # Core Web Vitals thresholds\n  PERFORMANCE_THRESHOLD_FID: 100\n  PERFORMANCE_THRESHOLD_CLS: 0.1\n\njobs:\n  # Security and dependency scanning\n  security-scan:\n    name: Security & Dependency Scan\n    runs-on: ubuntu-latest\n    if: github.event_name == 'pull_request'\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run security audit\n        run: |\n          npm audit --audit-level=high --production\n          npx audit-ci --config audit-ci.json\n\n      - name: Dependency vulnerability scan\n        uses: aquasecurity/trivy-action@master\n        with:\n          scan-type: 'fs'\n          scan-ref: '.'\n          format: 'sarif'\n          output: 'trivy-results.sarif'\n\n      - name: Upload Trivy scan results\n        uses: github/codeql-action/upload-sarif@v2\n        if: always()\n        with:\n          sarif_file: 'trivy-results.sarif'\n\n  # Quality and testing\n  test-and-quality:\n    name: Tests & Code Quality\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Type checking\n        run: npm run type-check || npx tsc --noEmit\n\n      - name: Linting\n        run: npm run lint\n\n      - name: Unit tests with coverage\n        run: npm run test:coverage\n        env:\n          CI: true\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage/lcov.info\n          flags: unittests\n          name: codecov-umbrella\n\n  # Build and validate\n  build-and-validate:\n    name: Build & Bundle Analysis\n    runs-on: ubuntu-latest\n    outputs:\n      bundle-size: ${{ steps.bundle-analysis.outputs.bundle-size }}\n      image-tag: ${{ steps.meta.outputs.tags }}\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Build application\n        run: npm run build:prod\n        env:\n          NODE_ENV: production\n          VITE_BUILD_MODE: production\n\n      - name: Bundle size analysis\n        id: bundle-analysis\n        run: |\n          BUNDLE_SIZE=$(du -sh dist/ | cut -f1)\n          echo \"bundle-size=$BUNDLE_SIZE\" >> $GITHUB_OUTPUT\n          echo \"Bundle size: $BUNDLE_SIZE\"\n          \n          # Analyze bundle composition\n          npm run build:analyze\n          \n          # Check bundle size thresholds\n          BUNDLE_SIZE_MB=$(du -sm dist/ | cut -f1)\n          if [ $BUNDLE_SIZE_MB -gt 10 ]; then\n            echo \"Warning: Bundle size exceeds 10MB threshold\"\n          fi\n\n      - name: Upload build artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: build-artifacts\n          path: |\n            dist/\n            dist/bundle-analysis.html\n          retention-days: 7\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Log in to Container Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=sha,prefix={{branch}}-\n            type=raw,value=latest,enable={{is_default_branch}}\n\n      - name: Build and push Docker images\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n          platforms: linux/amd64,linux/arm64\n          target: production\n\n  # Performance testing\n  performance-test:\n    name: Performance & Lighthouse Testing\n    runs-on: ubuntu-latest\n    needs: build-and-validate\n    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'\n    services:\n      redis:\n        image: redis:7.2-alpine\n        ports:\n          - 6379:6379\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Install Playwright\n        run: npx playwright install chromium\n\n      - name: Build for testing\n        run: npm run build:perf\n\n      - name: Start test server\n        run: |\n          npm run preview:perf &\n          sleep 10\n        env:\n          NODE_ENV: production\n\n      - name: Wait for server\n        run: |\n          timeout 60 bash -c 'until curl -f http://localhost:4173/health; do sleep 2; done'\n\n      - name: Run Lighthouse CI\n        uses: treosh/lighthouse-ci-action@v10\n        with:\n          urls: |\n            http://localhost:4173\n            http://localhost:4173/dashboard\n            http://localhost:4173/pipeline\n          configPath: './lighthouse.config.js'\n          uploadArtifacts: true\n          temporaryPublicStorage: true\n        env:\n          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}\n\n      - name: Core Web Vitals validation\n        run: |\n          node -e \"\n          const fs = require('fs');\n          const results = JSON.parse(fs.readFileSync('.lighthouseci/lhr-*.json'));\n          const lcp = results.audits['largest-contentful-paint'].numericValue;\n          const fid = results.audits['max-potential-fid'].numericValue;\n          const cls = results.audits['cumulative-layout-shift'].numericValue;\n          \n          console.log('Core Web Vitals:');\n          console.log('LCP:', lcp, 'ms (threshold: ${{ env.PERFORMANCE_THRESHOLD_LCP }}ms)');\n          console.log('FID:', fid, 'ms (threshold: ${{ env.PERFORMANCE_THRESHOLD_FID }}ms)');\n          console.log('CLS:', cls, '(threshold: ${{ env.PERFORMANCE_THRESHOLD_CLS }})');\n          \n          let failed = false;\n          if (lcp > ${{ env.PERFORMANCE_THRESHOLD_LCP }}) {\n            console.error('❌ LCP threshold exceeded');\n            failed = true;\n          }\n          if (fid > ${{ env.PERFORMANCE_THRESHOLD_FID }}) {\n            console.error('❌ FID threshold exceeded');\n            failed = true;\n          }\n          if (cls > ${{ env.PERFORMANCE_THRESHOLD_CLS }}) {\n            console.error('❌ CLS threshold exceeded');\n            failed = true;\n          }\n          \n          if (failed && '${{ github.event_name }}' === 'pull_request') {\n            process.exit(1);\n          }\n          console.log('✅ Performance thresholds passed');\n          \"\n\n      - name: E2E Performance Tests\n        run: npm run playwright\n        env:\n          BASE_URL: http://localhost:4173\n\n      - name: Upload performance artifacts\n        uses: actions/upload-artifact@v3\n        if: always()\n        with:\n          name: performance-results\n          path: |\n            .lighthouseci/\n            test-results/\n            playwright-report/\n          retention-days: 7\n\n  # Staging deployment\n  deploy-staging:\n    name: Deploy to Staging\n    runs-on: ubuntu-latest\n    needs: [test-and-quality, build-and-validate]\n    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_environment == 'staging')\n    environment:\n      name: staging\n      url: https://staging.yourdomain.com\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Deploy to staging\n        run: |\n          echo \"Deploying to staging environment...\"\n          # Add your staging deployment commands here\n          # Example: kubectl apply -f k8s/staging/\n          # Example: docker-compose -f docker-compose.staging.yml up -d\n        env:\n          KUBECONFIG: ${{ secrets.STAGING_KUBECONFIG }}\n          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}\n          SUPABASE_URL: ${{ secrets.STAGING_SUPABASE_URL }}\n          SUPABASE_ANON_KEY: ${{ secrets.STAGING_SUPABASE_ANON_KEY }}\n\n      - name: Run staging smoke tests\n        run: |\n          sleep 30  # Wait for deployment\n          curl -f https://staging.yourdomain.com/health || exit 1\n          curl -f https://staging.yourdomain.com/api/health || exit 1\n\n      - name: Staging performance validation\n        run: |\n          npx lighthouse https://staging.yourdomain.com --only-categories=performance --chrome-flags=\"--headless\" --output=json --output-path=staging-lighthouse.json\n          node -e \"\n          const report = JSON.parse(require('fs').readFileSync('staging-lighthouse.json'));\n          const score = report.categories.performance.score * 100;\n          console.log('Staging Performance Score:', score);\n          if (score < 80) {\n            console.error('❌ Staging performance score too low:', score);\n            process.exit(1);\n          }\n          console.log('✅ Staging performance acceptable');\n          \"\n\n  # Production deployment\n  deploy-production:\n    name: Deploy to Production\n    runs-on: ubuntu-latest\n    needs: [test-and-quality, build-and-validate, performance-test]\n    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_environment == 'production')\n    environment:\n      name: production\n      url: https://yourdomain.com\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Pre-deployment backup\n        run: |\n          echo \"Creating backup before deployment...\"\n          # Add backup commands here\n          # Example: pg_dump $DATABASE_URL > backup-$(date +%Y%m%d-%H%M%S).sql\n\n      - name: Blue-Green deployment setup\n        run: |\n          echo \"Setting up blue-green deployment...\"\n          # Add blue-green deployment logic here\n          # This could involve creating new instances, updating load balancers, etc.\n\n      - name: Deploy to production (Blue)\n        run: |\n          echo \"Deploying to production blue environment...\"\n          # Add your production deployment commands here\n          # Example: kubectl set image deployment/app app=${{ needs.build-and-validate.outputs.image-tag }}\n        env:\n          KUBECONFIG: ${{ secrets.PROD_KUBECONFIG }}\n          DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}\n          SUPABASE_URL: ${{ secrets.PROD_SUPABASE_URL }}\n          SUPABASE_ANON_KEY: ${{ secrets.PROD_SUPABASE_ANON_KEY }}\n          JWT_SECRET: ${{ secrets.PROD_JWT_SECRET }}\n\n      - name: Health check and warmup\n        run: |\n          echo \"Warming up new deployment...\"\n          sleep 30\n          \n          # Health checks\n          curl -f https://blue.yourdomain.com/health || exit 1\n          curl -f https://blue.yourdomain.com/api/health || exit 1\n          \n          # Warmup critical paths\n          curl -s https://blue.yourdomain.com/dashboard > /dev/null\n          curl -s https://blue.yourdomain.com/pipeline > /dev/null\n\n      - name: Production performance validation\n        run: |\n          npx lighthouse https://blue.yourdomain.com --only-categories=performance --chrome-flags=\"--headless\" --output=json --output-path=prod-lighthouse.json\n          node -e \"\n          const report = JSON.parse(require('fs').readFileSync('prod-lighthouse.json'));\n          const score = report.categories.performance.score * 100;\n          console.log('Production Performance Score:', score);\n          if (score < 85) {\n            console.error('❌ Production performance regression detected:', score);\n            process.exit(1);\n          }\n          console.log('✅ Production performance validated');\n          \"\n\n      - name: Switch traffic to Blue (Go Live)\n        run: |\n          echo \"Switching traffic to new deployment...\"\n          # Update load balancer or DNS to point to blue environment\n          # Example: kubectl patch service app -p '{\"spec\":{\"selector\":{\"version\":\"blue\"}}}'\n\n      - name: Post-deployment validation\n        run: |\n          sleep 60  # Allow time for DNS propagation\n          \n          # Final health checks\n          curl -f https://yourdomain.com/health || exit 1\n          curl -f https://yourdomain.com/api/health || exit 1\n          \n          # Monitor for errors\n          echo \"Monitoring for 5 minutes...\"\n          for i in {1..10}; do\n            STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" https://yourdomain.com/)\n            if [ $STATUS -ne 200 ]; then\n              echo \"❌ Health check failed with status $STATUS\"\n              exit 1\n            fi\n            sleep 30\n          done\n          echo \"✅ Deployment successful and stable\"\n\n      - name: Cleanup old deployment (Green)\n        run: |\n          echo \"Cleaning up old deployment...\"\n          # Remove or scale down old deployment\n          # Example: kubectl delete deployment app-green\n\n      - name: Update deployment status\n        run: |\n          echo \"Deployment completed successfully\"\n          echo \"Bundle size: ${{ needs.build-and-validate.outputs.bundle-size }}\"\n          echo \"Image: ${{ needs.build-and-validate.outputs.image-tag }}\"\n\n  # Rollback job (manual trigger only)\n  rollback:\n    name: Emergency Rollback\n    runs-on: ubuntu-latest\n    if: github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_environment == 'rollback'\n    environment:\n      name: production\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Rollback to previous version\n        run: |\n          echo \"Performing emergency rollback...\"\n          # Add rollback commands here\n          # Example: kubectl rollout undo deployment/app\n          # Example: Switch load balancer back to green environment\n\n      - name: Verify rollback\n        run: |\n          sleep 30\n          curl -f https://yourdomain.com/health || exit 1\n          echo \"✅ Rollback successful\"\n\n  # Monitoring and alerting\n  post-deploy-monitoring:\n    name: Post-Deploy Monitoring\n    runs-on: ubuntu-latest\n    needs: deploy-production\n    if: success() && (github.ref == 'refs/heads/main' || github.event.inputs.deploy_environment == 'production')\n    steps:\n      - name: Set up monitoring alerts\n        run: |\n          echo \"Setting up post-deployment monitoring...\"\n          # Add monitoring setup here\n          # Example: Update Prometheus alert rules\n          # Example: Send deployment notification to Slack\n\n      - name: Performance regression check\n        run: |\n          # Compare performance metrics with baseline\n          echo \"Checking for performance regressions...\"\n          # This could integrate with your monitoring system\n\n      - name: Send deployment notification\n        if: always()\n        run: |\n          STATUS=\"${{ job.status }}\"\n          WEBHOOK_URL=\"${{ secrets.SLACK_WEBHOOK_URL }}\"\n          \n          if [ \"$STATUS\" = \"success\" ]; then\n            MESSAGE=\"✅ Production deployment successful\\nBundle: ${{ needs.build-and-validate.outputs.bundle-size }}\\nCommit: ${{ github.sha }}\"\n          else\n            MESSAGE=\"❌ Production deployment failed\\nCommit: ${{ github.sha }}\"\n          fi\n          \n          curl -X POST -H 'Content-type: application/json' \\\n            --data \"{\\\"text\\\":\\\"$MESSAGE\\\"}\" \\\n            $WEBHOOK_URL"