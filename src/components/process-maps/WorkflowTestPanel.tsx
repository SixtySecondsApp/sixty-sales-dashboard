/**
 * Workflow Test Panel
 *
 * Slide-out panel for configuring and running workflow tests.
 * Displays test progress, results, and logs.
 *
 * Uses parseMermaidNodes to extract actual node IDs from the Mermaid diagram
 * so that highlighting works correctly with AI-generated diagrams.
 */

import React, { useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import {
  Play,
  X,
  Loader2,
  CheckCircle2,
  XCircle,
  AlertCircle,
  Clock,
  ChevronRight,
  RotateCcw,
  FileText,
  AlertTriangle,
  Database,
} from 'lucide-react';
import { toast } from 'sonner';
import type {
  ProcessMapStepResult,
  ProcessMapTestRun,
  ProcessStructure,
  RunMode,
  StepStatus,
  WorkflowStepDefinition,
  WorkflowStepType,
  LogEntry as TestLogEntry,
} from '@/lib/types/processMapTesting';
import {
  parseMermaidNodes,
  getOrderedNodeIds,
  type MermaidNode,
} from '@/lib/testing/parsers/WorkflowParser';
import { ProcessMapTestEngine } from '@/lib/testing/ProcessMapTestEngine';
import { convertProcessStructureToWorkflow } from '@/lib/testing/converters/processStructureConverter';
import { createTestMockRegistry, getAllMocksFromRegistry } from '@/lib/testing/mocks';

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Map Mermaid node shape type to WorkflowStepType
 */
function mapMermaidTypeToStepType(
  mermaidType: MermaidNode['type'],
  label: string,
  index: number,
  totalNodes: number
): WorkflowStepType {
  const labelLower = label.toLowerCase();

  // Check for specific keywords in the label first
  if (/webhook|trigger|event|receive|subscription|start/.test(labelLower)) {
    return 'trigger';
  }
  if (/notify|alert|email|message|slack|notification/.test(labelLower)) {
    return 'notification';
  }
  if (/store|save|database|table|record|insert|update/.test(labelLower)) {
    return 'storage';
  }
  if (/api|fetch|call|request|sync|oauth|endpoint/.test(labelLower)) {
    return 'external_call';
  }
  if (/transform|extract|parse|convert|map|process|ai|claude|analyze/.test(labelLower)) {
    return 'transform';
  }
  if (/check|verify|validate|condition|if|match/.test(labelLower)) {
    return 'condition';
  }

  // Use Mermaid shape type as fallback
  switch (mermaidType) {
    case 'start':
      return 'trigger';
    case 'end':
      return index === totalNodes - 1 ? 'notification' : 'action';
    case 'decision':
      return 'condition';
    case 'data':
      return 'storage';
    default:
      // Use position for additional hints
      if (index === 0) return 'trigger';
      if (index === totalNodes - 1) return 'notification';
      return 'action';
  }
}

/**
 * Detect integration name from node label keywords
 */
function detectIntegrationFromLabel(label: string): string | undefined {
  const labelLower = label.toLowerCase();

  const integrationPatterns: Record<string, RegExp> = {
    hubspot: /hubspot|deal|contact|crm|pipeline/,
    fathom: /fathom|transcript|recording|meeting|video/,
    google: /google|gmail|calendar|drive|workspace/,
    slack: /slack|channel|notification|bot/,
    justcall: /justcall|call|phone/,
    savvycal: /savvycal|booking|schedule/,
    supabase: /supabase|postgres|database|table/,
  };

  for (const [integration, pattern] of Object.entries(integrationPatterns)) {
    if (pattern.test(labelLower)) {
      return integration;
    }
  }

  return undefined;
}

// ============================================================================
// Types
// ============================================================================

interface WorkflowTestPanelProps {
  /** Whether the panel is open */
  isOpen: boolean;
  /** Callback when panel should close */
  onClose: () => void;
  /** Process map title for display */
  processMapTitle: string;
  /** Process map ID */
  processMapId: string;
  /** Mermaid code for the diagram */
  mermaidCode: string;
  /**
   * ProcessStructure JSON - the source of truth for nodes/steps.
   * When provided, this takes precedence over Mermaid parsing.
   * Generated by Claude Opus in Phase 1 of process map generation.
   */
  processStructure?: ProcessStructure | null;
  /** Callback when step status changes (for highlighting) */
  onStepStatusChange?: (stepStatuses: Map<string, StepStatus>) => void;
  /** Callback when current step changes */
  onCurrentStepChange?: (stepId: string | null) => void;
  /** If true, render without fixed positioning (for embedding in other containers) */
  embedded?: boolean;
}

// ============================================================================
// Step Status Icon Component
// ============================================================================

function StepStatusIcon({
  status,
  isCurrent,
}: {
  status?: StepStatus;
  isCurrent?: boolean;
}) {
  if (isCurrent && (!status || status === 'running')) {
    return <Loader2 className="h-4 w-4 text-blue-500 animate-spin" />;
  }

  switch (status) {
    case 'passed':
      return <CheckCircle2 className="h-4 w-4 text-green-500" />;
    case 'failed':
      return <XCircle className="h-4 w-4 text-red-500" />;
    case 'warning':
      return <AlertTriangle className="h-4 w-4 text-yellow-500" />;
    case 'skipped':
      return <ChevronRight className="h-4 w-4 text-gray-400" />;
    case 'running':
      return <Loader2 className="h-4 w-4 text-blue-500 animate-spin" />;
    default:
      return <Clock className="h-4 w-4 text-gray-400" />;
  }
}

// ============================================================================
// Step Progress Component
// ============================================================================

interface TestStepProgressProps {
  steps: WorkflowStepDefinition[];
  results: ProcessMapStepResult[];
  currentStepId?: string;
  isRunning: boolean;
}

function TestStepProgress({
  steps,
  results,
  currentStepId,
  isRunning,
}: TestStepProgressProps) {
  return (
    <div className="space-y-1">
      {steps.map((step, index) => {
        const result = results.find((r) => r.stepId === step.id);
        const isCurrent = currentStepId === step.id;

        return (
          <div
            key={step.id}
            className={cn(
              'flex items-center gap-3 p-2 rounded-md border transition-all duration-300',
              isCurrent && 'border-blue-500 bg-blue-50 dark:bg-blue-950/20',
              result?.status === 'passed' &&
                'border-green-200 bg-green-50 dark:bg-green-950/20',
              result?.status === 'failed' &&
                'border-red-200 bg-red-50 dark:bg-red-950/20',
              !result && !isCurrent && 'border-gray-200 dark:border-gray-800'
            )}
          >
            <div className="flex-shrink-0">
              <StepStatusIcon status={result?.status} isCurrent={isCurrent} />
            </div>

            <div className="flex-1 min-w-0">
              <div className="flex items-center gap-2">
                <span className="text-xs text-muted-foreground">{index + 1}.</span>
                <span className="text-sm font-medium truncate">{step.name}</span>
              </div>
              <div className="flex items-center gap-2 mt-0.5">
                <Badge variant="outline" className="text-[10px] px-1 py-0">
                  {step.type}
                </Badge>
                {step.integration && (
                  <Badge variant="secondary" className="text-[10px] px-1 py-0">
                    {step.integration}
                  </Badge>
                )}
              </div>
            </div>

            <div className="flex-shrink-0 text-right">
              {result?.durationMs !== null && result?.durationMs !== undefined && (
                <span className="text-xs text-muted-foreground">
                  {result.durationMs}ms
                </span>
              )}
            </div>
          </div>
        );
      })}
    </div>
  );
}

// ============================================================================
// Logs Viewer Component
// ============================================================================

interface LogEntry {
  timestamp: string;
  level: 'debug' | 'info' | 'warn' | 'error';
  message: string;
  data?: Record<string, unknown>;
}

function LogsViewer({ logs }: { logs: LogEntry[] }) {
  const scrollRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom when new logs arrive, but only if there are enough logs to scroll
  useEffect(() => {
    const el = scrollRef.current;
    if (el) {
      // Small delay to ensure content is rendered
      requestAnimationFrame(() => {
        // Only scroll if content overflows (i.e., there are enough logs to scroll)
        if (el.scrollHeight > el.clientHeight) {
          el.scrollTop = el.scrollHeight;
        }
      });
    }
  }, [logs.length]);

  const getLevelColor = (level: LogEntry['level']) => {
    switch (level) {
      case 'error':
        return 'text-red-500';
      case 'warn':
        return 'text-yellow-500';
      case 'info':
        return 'text-blue-500';
      default:
        return 'text-gray-500';
    }
  };

  if (logs.length === 0) {
    return (
      <div className="flex items-center justify-center h-full text-muted-foreground text-sm">
        No logs yet. Run a test to see logs.
      </div>
    );
  }

  return (
    <ScrollArea className="h-full" ref={scrollRef}>
      <div className="space-y-1 font-mono text-xs pb-4">
        {logs.map((log, index) => (
          <div key={index} className="flex gap-2 py-0.5">
            <span className="text-muted-foreground w-20 flex-shrink-0">
              {new Date(log.timestamp).toLocaleTimeString()}
            </span>
            <span className={cn('w-12 flex-shrink-0 uppercase', getLevelColor(log.level))}>
              [{log.level}]
            </span>
            <span className="flex-1 break-words">{log.message}</span>
          </div>
        ))}
      </div>
    </ScrollArea>
  );
}

// ============================================================================
// Main Component
// ============================================================================

export function WorkflowTestPanel({
  isOpen,
  onClose,
  processMapTitle,
  processMapId,
  mermaidCode,
  processStructure,
  onStepStatusChange,
  onCurrentStepChange,
  embedded = false,
}: WorkflowTestPanelProps) {
  // State
  const [runMode, setRunMode] = useState<RunMode>('mock');
  const [isRunning, setIsRunning] = useState(false);
  const [testRun, setTestRun] = useState<ProcessMapTestRun | null>(null);
  const [stepResults, setStepResults] = useState<ProcessMapStepResult[]>([]);
  const [currentStepId, setCurrentStepId] = useState<string | null>(null);
  const [logs, setLogs] = useState<LogEntry[]>([]);
  const [continueOnFailure, setContinueOnFailure] = useState(false);
  const [activeTab, setActiveTab] = useState('progress');

  // Parse Mermaid nodes to get actual node IDs for highlighting (fallback if no processStructure)
  const mermaidNodes = useMemo(() => {
    if (processStructure?.nodes) return []; // Don't parse if we have structure
    const nodes = parseMermaidNodes(mermaidCode);
    console.log('[WorkflowTestPanel] Parsed mermaid nodes:', nodes.map(n => ({ id: n.id, label: n.label })));
    return nodes;
  }, [mermaidCode, processStructure]);

  const orderedNodeIds = useMemo(() => {
    if (processStructure?.nodes) {
      // Use execution order from ProcessStructure
      const ordered = [...processStructure.nodes]
        .sort((a, b) => a.executionOrder - b.executionOrder)
        .map(n => n.id);
      console.log('[WorkflowTestPanel] Node IDs from ProcessStructure:', ordered);
      return ordered;
    }
    const ids = getOrderedNodeIds(mermaidCode);
    console.log('[WorkflowTestPanel] Ordered node IDs from Mermaid:', ids);
    return ids;
  }, [mermaidCode, processStructure]);

  // Convert to WorkflowStepDefinition format
  // Prefer ProcessStructure (source of truth) when available, fallback to Mermaid parsing
  const workflowSteps: WorkflowStepDefinition[] = useMemo(() => {
    // If we have ProcessStructure, use it directly (this is the source of truth)
    if (processStructure?.nodes && processStructure.nodes.length > 0) {
      console.log('[WorkflowTestPanel] Using ProcessStructure nodes:', processStructure.nodes.length);

      // Sort by execution order
      const sortedNodes = [...processStructure.nodes].sort((a, b) => a.executionOrder - b.executionOrder);

      return sortedNodes.map((node, index) => ({
        id: node.id,
        name: node.label,
        type: node.stepType,
        integration: node.integration,
        description: node.description,
        inputSchema: { type: 'object' as const },
        outputSchema: { type: 'object' as const },
        dependencies: index > 0 ? [sortedNodes[index - 1].id] : [],
        testConfig: {
          mockable: node.testConfig?.mockable ?? true,
          timeout: 30000,
          retryCount: 2,
          requiresRealApi: node.testConfig?.requiresRealApi,
          operations: node.testConfig?.operations,
        },
      }));
    }

    // Fallback: Parse from Mermaid code
    if (mermaidNodes.length === 0) {
      // Fallback to demo steps if no nodes found
      return [
        {
          id: 'demo_1',
          name: 'Step 1',
          type: 'trigger' as WorkflowStepType,
          description: 'No workflow nodes detected in diagram',
          inputSchema: { type: 'object' },
          outputSchema: { type: 'object' },
          dependencies: [],
          testConfig: { mockable: true, timeout: 30000, retryCount: 2 },
        },
      ];
    }

    console.log('[WorkflowTestPanel] Falling back to Mermaid parsing');

    // Use orderedNodeIds to maintain execution order
    return orderedNodeIds.map((nodeId, index) => {
      const node = mermaidNodes.find((n) => n.id === nodeId);
      if (!node) {
        return {
          id: nodeId,
          name: nodeId,
          type: 'action' as WorkflowStepType,
          description: '',
          inputSchema: { type: 'object' as const },
          outputSchema: { type: 'object' as const },
          dependencies: index > 0 ? [orderedNodeIds[index - 1]] : [],
          testConfig: { mockable: true, timeout: 30000, retryCount: 2 },
        };
      }

      // Map Mermaid node type to WorkflowStepType
      const stepType = mapMermaidTypeToStepType(node.type, node.label, index, mermaidNodes.length);

      // Detect integration from label keywords
      const integration = detectIntegrationFromLabel(node.label);

      return {
        id: node.id, // Use actual Mermaid node ID
        name: node.label,
        type: stepType,
        integration,
        description: node.section ? `Part of ${node.section}` : undefined,
        inputSchema: { type: 'object' as const },
        outputSchema: { type: 'object' as const },
        dependencies: index > 0 ? [orderedNodeIds[index - 1]] : [],
        testConfig: { mockable: stepType !== 'storage', timeout: 30000, retryCount: 2 },
      };
    });
  }, [processStructure, mermaidNodes, orderedNodeIds]);

  // Handle step status changes
  useEffect(() => {
    if (onCurrentStepChange) {
      onCurrentStepChange(currentStepId);
    }
  }, [currentStepId, onCurrentStepChange]);

  useEffect(() => {
    if (onStepStatusChange) {
      const statusMap = new Map<string, StepStatus>();
      for (const result of stepResults) {
        statusMap.set(result.stepId, result.status);
      }
      if (currentStepId && !statusMap.has(currentStepId)) {
        statusMap.set(currentStepId, 'running');
      }
      onStepStatusChange(statusMap);
    }
  }, [stepResults, currentStepId, onStepStatusChange]);

  // Run test using real ProcessMapTestEngine with mocks
  const handleRunTest = useCallback(async () => {
    setIsRunning(true);
    setStepResults([]);
    setLogs([]);
    setTestRun(null);
    setActiveTab('progress');

    const addLog = (level: LogEntry['level'], message: string, data?: Record<string, unknown>) => {
      setLogs((prev) => [...prev, { timestamp: new Date().toISOString(), level, message, data }]);
    };

    addLog('info', `Starting test run in ${runMode} mode`);

    // Track results locally since React state updates are async
    const localResults: ProcessMapStepResult[] = [];

    try {
      // Convert ProcessStructure to ProcessMapWorkflow
      // Detect integrations from workflow steps
      const integrations = Array.from(
        new Set(
          workflowSteps
            .map((s) => s.integration)
            .filter((i): i is string => !!i)
        )
      );

      addLog('info', `Detected integrations: ${integrations.length > 0 ? integrations.join(', ') : 'none'}`);

      // Create workflow for engine
      const workflow = processStructure
        ? convertProcessStructureToWorkflow(processStructure, {
            workflowId: processMapId,
            orgId: 'test-org', // Will be replaced with actual org ID when available
          })
        : {
            id: processMapId,
            name: processMapTitle,
            orgId: 'test-org',
            version: 1,
            steps: workflowSteps,
            metadata: {
              mermaidCode,
            },
          };

      addLog('debug', `Workflow created with ${workflow.steps.length} steps`);

      // Create mock registry with detected integrations
      const mockRegistry = createTestMockRegistry(
        processMapId,
        'test-org',
        integrations.length > 0 ? (integrations as Array<'hubspot' | 'fathom' | 'google' | 'slack' | 'justcall' | 'savvycal' | 'supabase'>) : undefined
      );
      const mocks = getAllMocksFromRegistry(mockRegistry);

      addLog('debug', `Loaded ${mocks.length} mock configurations`);

      // Create and run the test engine
      const engine = new ProcessMapTestEngine({
        workflow,
        runMode,
        config: {
          continueOnFailure,
          timeout: 300000, // 5 minutes
        },
        mocks,
        events: {
          onStepStart: (stepId: string, stepName: string) => {
            setCurrentStepId(stepId);
            addLog('info', `Starting step: ${stepName}`);
          },
          onStepComplete: (result: ProcessMapStepResult) => {
            // Add ID to result if not present
            const fullResult: ProcessMapStepResult = {
              ...result,
              id: result.id || `result_${Date.now()}_${result.sequenceNumber}`,
            };
            localResults.push(fullResult);
            setStepResults((prev) => [...prev, fullResult]);

            const statusMessage = result.status === 'passed'
              ? `Step ${result.stepName}: passed`
              : result.status === 'failed'
                ? `Step ${result.stepName}: failed - ${result.errorMessage || 'Unknown error'}`
                : `Step ${result.stepName}: ${result.status}`;

            addLog(
              result.status === 'passed' ? 'info' : result.status === 'failed' ? 'error' : 'warn',
              statusMessage
            );

            if (result.wasMocked) {
              addLog('debug', `  → Mocked via ${result.mockSource || 'default mock'}`);
            }
            if (result.durationMs !== null && result.durationMs !== undefined) {
              addLog('debug', `  → Duration: ${result.durationMs}ms`);
            }
          },
          onLog: (log: TestLogEntry) => {
            addLog(log.level, log.message, log.data);
          },
          onError: (error: Error) => {
            addLog('error', `Engine error: ${error.message}`);
          },
        },
      });

      // Execute the test
      const { testRun: runResult } = await engine.run();

      setTestRun(runResult as ProcessMapTestRun);
      addLog('info', `Test run completed: ${runResult.stepsPassed} passed, ${runResult.stepsFailed} failed`);

      if (runResult.overallResult === 'pass') {
        toast.success(`All ${runResult.stepsPassed} tests passed!`);
      } else if (runResult.overallResult === 'partial') {
        toast.warning(`${runResult.stepsPassed} passed, ${runResult.stepsFailed} failed`);
      } else {
        toast.error(`Test failed: ${runResult.errorMessage || 'Unknown error'}`);
      }
    } catch (error) {
      const err = error as Error;
      addLog('error', `Test execution failed: ${err.message}`);
      toast.error(`Test execution failed: ${err.message}`);
    } finally {
      setCurrentStepId(null);
      setIsRunning(false);
    }
  }, [runMode, continueOnFailure, workflowSteps, processStructure, processMapId, processMapTitle, mermaidCode]);

  // Reset test state
  const handleReset = useCallback(() => {
    setTestRun(null);
    setStepResults([]);
    setLogs([]);
    setCurrentStepId(null);
  }, []);

  if (!isOpen) return null;

  // Inner content shared between embedded and standalone modes
  const testContent = (
    <>
      {/* Configuration */}
      <div className="p-4 space-y-4 border-b">
        <div className="space-y-2">
          <Label htmlFor="run-mode">Run Mode</Label>
          <Select
            value={runMode}
            onValueChange={(value) => setRunMode(value as RunMode)}
            disabled={isRunning}
          >
            <SelectTrigger id="run-mode">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="schema_validation">
                <div className="flex items-center gap-2">
                  <FileText className="h-4 w-4" />
                  Schema Validation
                </div>
              </SelectItem>
              <SelectItem value="mock">
                <div className="flex items-center gap-2">
                  <Database className="h-4 w-4" />
                  Mock Mode
                </div>
              </SelectItem>
              <SelectItem value="production_readonly">
                <div className="flex items-center gap-2">
                  <AlertCircle className="h-4 w-4" />
                  Production (Read-Only)
                </div>
              </SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="flex items-center justify-between">
          <Label htmlFor="continue-on-failure">Continue on failure</Label>
          <Switch
            id="continue-on-failure"
            checked={continueOnFailure}
            onCheckedChange={setContinueOnFailure}
            disabled={isRunning}
          />
        </div>

        <div className="flex gap-2">
          <Button onClick={handleRunTest} disabled={isRunning} className="flex-1">
            {isRunning ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Running...
              </>
            ) : (
              <>
                <Play className="mr-2 h-4 w-4" />
                Run Test
              </>
            )}
          </Button>
          <Button
            variant="outline"
            onClick={handleReset}
            disabled={isRunning || stepResults.length === 0}
          >
            <RotateCcw className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Results */}
      <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col min-h-0">
        <div className="px-4 pt-2">
          <TabsList className="w-full">
            <TabsTrigger value="progress" className="flex-1">
              Progress
            </TabsTrigger>
            <TabsTrigger value="logs" className="flex-1">
              Logs
            </TabsTrigger>
          </TabsList>
        </div>

        <TabsContent value="progress" className="p-4 pt-2 flex-1 flex flex-col min-h-0 overflow-hidden">
          {/* Summary */}
          {stepResults.length > 0 && (
            <Card className="mb-4 flex-shrink-0">
              <CardContent className="py-3">
                <div className="flex items-center justify-around text-center">
                  <div>
                    <div className="text-2xl font-bold text-green-500">
                      {stepResults.filter((r) => r.status === 'passed').length}
                    </div>
                    <div className="text-xs text-muted-foreground">Passed</div>
                  </div>
                  <Separator orientation="vertical" className="h-8" />
                  <div>
                    <div className="text-2xl font-bold text-red-500">
                      {stepResults.filter((r) => r.status === 'failed').length}
                    </div>
                    <div className="text-xs text-muted-foreground">Failed</div>
                  </div>
                  <Separator orientation="vertical" className="h-8" />
                  <div>
                    <div className="text-2xl font-bold text-gray-500">
                      {workflowSteps.length - stepResults.length}
                    </div>
                    <div className="text-xs text-muted-foreground">Pending</div>
                  </div>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Steps list with scroll indicator */}
          <div className="flex-1 min-h-0 relative">
            <ScrollArea className="h-full">
              <TestStepProgress
                steps={workflowSteps}
                results={stepResults}
                currentStepId={currentStepId || undefined}
                isRunning={isRunning}
              />
            </ScrollArea>
            {/* Bottom fade indicator when there's more content */}
            {workflowSteps.length > 5 && (
              <div className="absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-background to-transparent pointer-events-none" />
            )}
          </div>
        </TabsContent>

        <TabsContent value="logs" className="p-4 pt-2 flex-1 min-h-0 overflow-hidden">
          <LogsViewer logs={logs} />
        </TabsContent>
      </Tabs>
    </>
  );

  // Embedded mode: render content directly without positioning
  if (embedded) {
    return (
      <div className="flex flex-col h-full bg-background">
        {testContent}
      </div>
    );
  }

  // Standalone mode: fixed position slide-out panel
  return (
    <div
      className={cn(
        'fixed inset-y-0 right-0 z-50 w-[400px] bg-background shadow-lg border-l',
        'transform transition-transform duration-300 ease-in-out',
        isOpen ? 'translate-x-0' : 'translate-x-full'
      )}
    >
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b">
        <div>
          <h2 className="font-semibold">Test Workflow</h2>
          <p className="text-sm text-muted-foreground truncate max-w-[280px]">
            {processMapTitle}
          </p>
        </div>
        <Button variant="ghost" size="icon" onClick={onClose}>
          <X className="h-4 w-4" />
        </Button>
      </div>

      {testContent}
    </div>
  );
}

// ============================================================================
// Exports
// ============================================================================

export default WorkflowTestPanel;
export type { WorkflowTestPanelProps };
